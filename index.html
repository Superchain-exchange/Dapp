<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Superchain Launchpad</title>
    
    <link rel="icon" href="https://raw.githubusercontent.com/parzivalishan/newsuper/main/assets/superchain.png" type="image/png">

    
    <!-- Ethers.js -->
    <script src="https://cdn.jsdelivr.net/npm/ethers@5.6.9/dist/ethers.umd.min.js"></script>
  

    <script src="https://cdn.jsdelivr.net/npm/web3/dist/web3.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #0B0C0E; /* Dark black color resembling SpaceX */
            margin: 0; /* Remove default margin */
            padding: 0; /* Remove default padding */
            height: 100vh; /* Full height */
            display: flex; /* Use flexbox for alignment */
            flex-direction: column; /* Column layout */
            align-items: flex-end; /* Align items to the right */
            justify-content: flex-start; /* Align items to the top */
        }

        #header {
            width: 100%; /* Full width */
            display: flex; /* Flex layout for buttons */
            justify-content: flex-end; /* Align buttons to the right */
            padding: 10px; /* Padding for buttons */
            position: absolute; /* Position absolute for top alignment */
            top: 0; /* Align to the top */
        }

        #app {
    background-color: rgb(26, 60, 141);
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
    max-width: 600px; /* Increased width */
    width: 100%; /* Full width for responsiveness */
    margin: auto;
    text-align: center; /* Center text within the app */
    position: relative;
    top: 35%; /* Adjusted to be higher on the page */
    transform: translateY(-50%);
    left: 430px; /* Shift to the right by 50px */
}

h1 {
    font-size: 24px;
}
#app2 {
    background-color: rgb(50, 50, 50); /* Background color for app2 */
    padding: 40px; /* Increased padding for more space inside */
    border-radius: 15px; /* More rounded corners */
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2); /* Deeper shadow */
    max-width: 750px; /* Increased max width */
    width: calc(80% - 20px); /* Adjusted width for more margin */
    position: absolute; /* Allows you to position the element freely */
    top: 60px; /* Adjusted distance from the top */
    left: 10px; /* Centering based on width */
    right: 10px; /* Adjusted distance from the right edge */
    text-align: center; /* Center align text in app2 */
}




    

   

    #myPieChart {
        width: 350px !important; /* Set the width to 150px */
        height: 350px !important; /* Set the height to 150px */
    }
   

#connectWalletBtn, #networkBtn, #predictionMarketBtn , #disperseBtn  {
    padding: 10px 20px;
    font-size: 16px;
    background-color: #0B0C0E; /* Button color for all three */
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    margin-left: 10px; /* Space between buttons */
    position: relative; /* Relative position for dropdown */
}

#connectWalletBtn:hover, #networkBtn:hover, #predictionMarketBtn, #disperseBtn:hover {
    background-color: #0056b3; /* Hover color */
}

.network-select {
    background-color: #3B82F6;
    color: white;
    border: none;
    border-radius: 5px;
    padding: 10px;
    font-size: 16px;
    cursor: pointer;
    position: absolute;
    top: 20px;
    right: 0px; /* Adjusted to maintain spacing with the raise button */
}

#dropdownContent {
    position: absolute; /* Keep it absolute */
    top: 100%; /* Position it directly below the button */
    right: 130px; /* Distance from the right side */
    display: none; /* Hidden by default */
    background-color: white; /* Background color for dropdown */
    border: 1px solid #ccc; /* Optional border for better visibility */
    border-radius: 5px; /* Rounded corners */
    z-index: 1000; /* Ensure it appears above other elements */
}

#dropdownContent button {
    border: none;
    padding: 10px 20px; /* Adjust padding for better appearance */
    text-align: center; /* Center align text */
    background-color: #0B0C0E; /* Same color as connect button */
    color: white; /* Text color */
    cursor: pointer; /* Pointer on hover */
    margin: 0; /* No margin for dropdown items to stack vertically */
    width: 100%; /* Make buttons full width for better alignment */
    display: flex; /* Use flexbox for alignment */
    align-items: center; /* Center items vertically within the button */
}

#dropdownContent button:hover {
    background-color: #3B82F6; /* Background color on hover */
    color: white; /* Text color on hover */
}

#dropdownContent .logo {
    width: 24px; /* Set a fixed width for logos */
    height: 24px; /* Set a fixed height for logos */
    margin-right: 8px; /* Space between logo and text */
    vertical-align: middle; /* Align logo vertically in line with text (not strictly necessary with flexbox) */
}

button#sendTransactionBtn {
    padding: 10px 20px;
    font-size: 16px;
    background-color: #007BFF; /* Same color as connect button */
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    margin-top: 10px; /* Space above the button */
}

button#sendTransactionBtn:hover {
    background-color: #0056b3; /* Hover color */
}



    /* New CSS for the SCE Send Button */
    button#sendSceTokenBtn {
        padding: 10px 20px;
    font-size: 16px;
    background-color: #007BFF; /* Same color as connect button */
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    margin-top: 10px; /* Space above the button */
}

    button#sendSceTokenBtn:hover {
        background-color: #0056b3; /* Hover color */
    }

/* Input field styling */
input[type="number"] {
    -moz-appearance: textfield; /* Remove default spinner in Firefox */
    outline: none; /* Optional: remove outline on focus */
}

/* Hide the spinner in WebKit browsers (Chrome, Safari) */
input[type="number"]::-webkit-inner-spin-button,
input[type="number"]::-webkit-outer-spin-button {
    -webkit-appearance: none; /* Remove default spinner in Chrome/Safari */
    margin: 0; /* Remove margin */
}

/* Optional: Additional styling for better appearance */
input[type="number"] {
    padding: 8px; /* Add some padding */
    border: 1px solid #ccc; /* Add a border */
    border-radius: 4px; /* Rounded corners */
    font-size: 16px; /* Font size */
}

/* Optional: Focus styling */
input[type="number"]:focus {
    border-color: #007bff; /* Change border color on focus */
    box-shadow: 0 0 5px rgba(0, 123, 255, 0.5); /* Add shadow on focus */
}

/* Existing input styles (you can keep them as is) */
input {
    width: calc(100% - 400px); /* Adjusted width to make input shorter */
    padding: 12px;
    margin: 10px 0;
    border-radius: 8px; /* Softer rounded corners */
    border: 1px solid #ccc;
    background-color: #f5f5f5; /* Light background for a modern feel */
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); /* Subtle shadow for depth */
    box-sizing: border-box; /* Ensure padding is included in total width */
    text-align: center; /* Center text in inputs */
    font-size: 16px;
    transition: all 0.3s ease; /* Smooth transition for effects */
}

/* Change border color and shadow on hover */
input:hover {
    border-color: #007BFF; /* Change to primary blue */
}

/* Change appearance on focus */
input:focus {
    border-color: #007BFF; /* Highlight border on focus */
    outline: none; /* Remove default outline */
    box-shadow: 0 4px 8px rgba(0, 123, 255, 0.2); /* Increase shadow on focus */
    background-color: #fff; /* Slightly brighten background on focus */
}

/* Placeholder text styling */
input::placeholder {
    color: #888; /* Light gray for placeholders */
    font-style: italic;
}

/* Parent container for positioning */
.button-container {
    position: relative; /* Set the parent as relative */
    width: calc(100% - 20px); /* Adjust width to fit within padding */
    margin-top: 10px; /* Space above the container */
}

#maxButton {
    position: absolute; 
    background-color: #4CAF50; 
    color: white; 
    border: none; 
    padding: 12px 20px; /* Match vertical padding with input field */
    font-size: 16px; 
    cursor: pointer; 
    border-radius: 8px; 

    right: 130px; /* Move it left from the right edge */
    top: 10px;   
    
    height: calc(100% - 20px); /* Adjust height to match input field (considering margins) */
}

/* Hover and active states for Max button */
#maxButton:hover {
    background-color: #45a049; 
}

#maxButton:active {
    transform: scale(0.95); 
}
#txStatus {
    display: none; /* Hide by default */
    margin-top: 20px;
    color: #ffffff; /* Change to white for better contrast */
    background-color: #333333; /* Dark background for contrast */
    padding: 10px; /* Add some padding for better spacing */
    border-radius: 5px; /* Rounded corners for aesthetics */
    font-weight: bold; /* Make text bold */
    font-size: 16px; /* Increase font size for readability */
}

#txStatus.show {
    display: block; /* Show when this class is added */
}
        .hidden {
            display: none;
        }

        #socials {
    position: fixed;
    bottom: 10px; /* Adjusts vertical position */
    right: 20px;  /* Adjusts horizontal position */
    display: flex; /* Align buttons in a row */
    gap: 10px; /* Space between buttons */
}

.social-icon img {
    width: 40px;
    height: 40px;
    background-color: #0B0C0E; /* Set to SpaceX-like color */
    border-radius: 50%; /* Optional, for circular effect */
    transition: transform 0.2s; /* For hover effect */
}

.social-icon:hover img {
    transform: scale(1.1); /* Slight zoom effect on hover */
}












/* Hide original progress elements */
#progressLabel,
#progressPercentage,
.progress-container-original {
    display: none; /* Hide these elements */
}

/* General progress bar container styling for the original progress bar */
.progress-container-original {
    width: 100%; /* Full width */
    height: 20px; /* Height of the progress bar */
    border-radius: 8px; /* Softer, rounded corners */
    background-color: #e0e0e0; /* Light gray background for the container */
    overflow: hidden; /* Ensure rounded corners remain visible */
    box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.2); /* Optional inner shadow for depth */
}

/* New progress bar container styling for progressBar2 */
.progress-container-2 {
    width: 100%; /* Full width */
    height: 20px; /* Height of the progress bar */
    border-radius: 8px; /* Softer, rounded corners */
    background-color: #e0e0e0; /* Light gray background for the container */
    overflow: hidden; /* Ensure rounded corners remain visible */
    box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.2); /* Optional inner shadow for depth */
}

/* General progress bar styling for progressBar2 */
#progressBar2 {
    appearance: none; /* Remove default styles */
    width: 100%; /* Full width */
    height: 100%; /* Full height of the container */
    border-radius: 8px; /* Softer, more modern rounded corners */
}

/* Webkit-specific styling (Chrome, Safari, etc.) for progressBar2 */
#progressBar2::-webkit-progress-bar {
    background-color: #e0e0e0; /* Light gray background for the container */
}

#progressBar2::-webkit-progress-value {
    background-color: #FF0000; /* YouTube red color for the progress value */
    border-radius: 8px; /* Keep the rounded corners for the progress value */
    transition: width 0.4s ease-in-out; /* Smooth animation on progress change */
}

/* Mozilla Firefox-specific styling for progressBar2 */
#progressBar2::-moz-progress-bar {
    background-color: #FF0000; /* YouTube red color for the progress value */
    border-radius: 8px;
    transition: width 0.4s ease-in-out; /* Smooth animation on progress change */
}

/* Optional: Add hover effect for extra interaction on progressBar2 */
#progressBar2:hover::-webkit-progress-value,
#progressBar2:hover::-moz-progress-bar {
    background-color: #CC0000; /* Darker red on hover */
}

/* Optional: Add a glow effect when the progress is complete on progressBar2 */
#progressBar2[value="100"]::-webkit-progress-value,
#progressBar2[value="100"]::-moz-progress-bar {
    box-shadow: 0 0 10px rgba(255, 0, 0, 1); /* Glow effect for completed progress */
}


#disperseBtn {
    padding: 10px 20px;
    font-size: 16px;
    background-color: #0B0C0E; /* Match the button color with connect and network buttons */
    color: white; /* Text color */
    border: none;
    border-radius: 5px;
    cursor: pointer;
    margin-left: 10px; /* Space between buttons */
    position: relative; /* Relative position for dropdown */
}

#disperseBtn:hover {
    background-color: #0056b3; /* Hover color */
}

#predictionMarketBtn {
    padding: 10px 20px;
    font-size: 16px;
    background-color: #0B0C0E; /* Match the button color with connect and network buttons */
    color: white; /* Text color */
    border: none;
    border-radius: 5px;
    cursor: pointer;
    margin-left: 10px; /* Space between buttons */
    position: relative; /* Relative position for dropdown */
}

#predictionMarketBtn:hover {
    background-color: #0056b3; /* Hover color */
}
.loader {
    border: 16px solid #f3f3f3; /* Light grey */
    border-top: 16px solid #3498db; /* Blue */
    border-radius: 50%;
    width: 120px;
    height: 120px;
    animation: spin 2s linear infinite;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }





}

.info-container {
    display: flex; /* Use flexbox for alignment */
    justify-content: center; /* Center items horizontally */
    align-items: center; /* Align items vertically centered */
}

#raisedAmount, #tokenBalance {
    margin-right: 10px; /* Optional: add space between the elements */
}


    </style>
</head>
<body>
    
    <div id="header">
        
        <button id="disperseBtn">Disperse Tokens </button> 
        <button id="predictionMarketBtn">Prediction Market</button> <!-- New Prediction Market button -->
        <button id="networkBtn">Network</button> <!-- Network button -->
        <div id="dropdownContent">
            <button id="minatoNetworkBtn" class="network-button">
                <img src="https://bridge.soneium.org/icon-soneium.svg" alt="Minato Logo" class="logo" />
                Minato
            </button>
            
            <button id="sepoliaNetworkBtn" class="network-button">
                <img src="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='28' height='28' fill='none'><path fill='%2325292E' fill-rule='evenodd' d='M14 28a14 14 0 1 0 0-28 14 14 0 0 0 0 28Z' clip-rule='evenodd'/><path fill='url(%23a)' fill-opacity='.3' fill-rule='evenodd' d='M14 28a14 14 0 1 0 0-28 14 14 0 0 0 0 28Z' clip-rule='evenodd'/><path fill='url(%23b)' d='M8.19 14.77 L14 18.21l5.8-3.44-5.8 8.19-5.81-8.19Z'/><path fill='%23fff' d='m14 16.93-5.81-3.44L14 4.34l5.81 9.15L14 16.93Z'/><defs><linearGradient id='a' x1='0' x2='14' y1='0' y2='28' gradientUnits='userSpaceOnUse'><stop stop-color='%23fff'/><stop offset='1' stop-color='%23fff' stop-opacity='0'/></linearGradient><linearGradient id='b' x1='14' x2='14' y1='14.77' y2='22.96' gradientUnits='userSpaceOnUse'><stop stop-color='%23fff'/><stop offset='1' stop-color='%23fff' stop-opacity='.9'/></linearGradient></defs></svg>" alt="Sepolia Logo" class="logo" />
                Sepolia
            </button>
        </div>
        <button id="connectWalletBtn">Connect Wallet</button> <!-- Connect Wallet button -->
    </div>

    <div id="app2">
        <h1>Vitalik Token IDO</h1>
        
        <!-- Project Information -->
        <div style="margin-top: 20px;">
            <h2>About the Project</h2>
            <p>
                Vitalik L1 with a library of 30+ chicks under 25 planning to generate revenue from advertisements and micro transactions that are shared with other simps. Token utility includes L1 gas fees and Ftx Bankruptcy purchase currency for all game related NFTs. Players can play any game, use the same digital assets in multiple games and be rewarded daily for the activities. Web 2.5 infrastructure enables access to 3 billion players.
            </p>
        </div>
    
        <!-- Team Section -->
        <div style="margin-top: 20px;">
            <h2>Meet the Team</h2>
            <ul>
                <li><strong>Do Kwon</strong> - CEO & Founder</li>
                <li><strong>Sam Bankman Fried</strong> - CTO & Co-Founder</li>
                <li><strong>Su Zhu</strong> - Marketing Director</li>
            </ul>
        </div>
    
        <!-- Vesting Information -->
        <div style="margin-top: 20px;">
            <h2>Vesting Information</h2>
            <p>
                I will add it soon :_:
            </p>
        </div>
    
        <!-- Smaller Pie Chart Canvas -->
        <div style="margin-top: 20px;">
            <canvas id="myPieChart" width="2" height="2" style="max-width: 100%;"></canvas>
        </div>
        
        <!-- Social Media Links -->
        <div style="margin-top: 20px;">
            <h2>Vitalik L1 Socials</h2>
            <a href="https://telegram.org/" target="_blank">
                <img src="https://upload.wikimedia.org/wikipedia/commons/8/82/Telegram_logo.svg" alt="Telegram" style="width: 30px; margin-right: 10px;">
            </a>
            <a href="https://x.com/" target="_blank">
                <img src="https://upload.wikimedia.org/wikipedia/commons/6/6f/Logo_of_Twitter.svg" alt="Twitter" style="width: 30px; margin-right: 10px;">
            </a>
            <a href="https://www.yourwebsite.com/" target="_blank">
                <img src="https://raw.githubusercontent.com/parzivalishan/newsuper/refs/heads/main/assets/website%20logo.jpg" alt="Website" style="width: 30px; margin-right: 10px;">
            </a>
        </div>
    </div>
    
    
    
    <script>
        // Initialize the pie chart with some default data
        const ctx = document.getElementById('myPieChart').getContext('2d');
        let myPieChart = new Chart(ctx, {
            type: 'pie',
            data: {
                labels: ['Private Sale', 'IDO', 'Liquidity', 'Team'], // These labels can be descriptive
                datasets: [{
                    label: 'Token Distribution',
                    data: [30, 40, 20, 10], // Predefined data for the pie chart
                    backgroundColor: [
                        'rgba(255, 99, 132, 0.6)',
                        'rgba(54, 162, 235, 0.6)',
                        'rgba(255, 206, 86, 0.6)',
                        'rgba(75, 192, 192, 0.6)'
                    ],
                    borderColor: [
                        'rgba(255, 99, 132, 1)',
                        'rgba(54, 162, 235, 1)',
                        'rgba(255, 206, 86, 1)',
                        'rgba(75, 192, 192, 1)'
                    ],
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                plugins: {
                    legend: {
                        position: 'top',
                    },
                    tooltip: {
                        callbacks: {
                            label: function(tooltipItem) {
                                return `${tooltipItem.label}: ${tooltipItem.raw}`;
                            }
                        }
                    }
                }
            }
        });
    
        // You can update the pie chart dynamically in the future if needed
        // For example, using some predefined conditions or data fetch.
        // Here's an example of how to update data programmatically:
        setTimeout(() => {
            const newData = [20, 30, 25, 25]; // New data for demonstration
            myPieChart.data.datasets[0].data = newData;
            myPieChart.update();
        }, 5000); // Update after 5 seconds for demonstration
    </script>
    
    
    
    <div id="app">
        <h1> SuperChain ( Minato Network ) </h1>

        <div id="accountDisplay" class="hidden">
            <p>
                ETH Balance: <span id="balanceAmount"></span>  |
                USDS Balance: <span id="tokenBalanceAmount"></span> 
            </p>
        </div>
        
        <p id="walletStatus" class="hidden">Please switch to Minato network</p>

        <div id="crypto-info">
            <h2></h2>
            <p>Current Price ETH: <span id="ethPrice">Fetching...</span></p>
            <div class="info-container">
                <p id="raisedAmount" class="hidden">
                    Raised Amount: <span id="raisedEthAmount">0.01</span> ETH (~$<span id="raisedUsdAmount">0.00</span>)
                </p>
                <p id="tokenBalance">|     Token Balance: 0 Tokens</p>
            </div>

            <p> <span id="usdAmountRaised">0.00</span></p>

            <p>Percentage Raised: <span id="percentageRaised">0%</span></p>
            <div class="progress-container-2">
                <progress id="progressBar2" value="0" max="100"></progress>
            </div>
            
            <div id="result"></div>
            <div id="debug"></div>
            <div id="loading" class="loader" style="display: none;"></div>
            
            <label for="progressScale" id="progressLabel">Sale Progress:</label>
            <span id="progressPercentage">0%</span>
            <div class="progress-container-original">
                <progress id="progressScale" value="0" max="100"></progress>
            </div>


<input type="text" id="recipientAddress" placeholder="Recipient Address" value="0xad3a5DdCe484251f8839f185896b14605b8dd340">

<div class="button-container">
    <input type="number" id="amountToSend" placeholder="Amount to Send ">
    <button id="maxButton">Max</button>
</div>
<button id="sendTransactionBtn" class="hidden">
    <img src="https://raw.githubusercontent.com/parzivalishan/newsuper/refs/heads/main/assets/eth%20logo.png" alt="ETH Logo" style="width: 20px; height: 20px; vertical-align: middle; margin-right: 5px;">
    Send
</button>

<button id="sendSceTokenBtn">
    <img src="https://raw.githubusercontent.com/parzivalishan/newsuper/refs/heads/main/assets/usdt%20logo.png" alt="SCE Logo" style="width: 20px; height: 20px; vertical-align: middle; margin-right: 5px;">
    Send 
</button>
            
        </div>

        <div id="txStatus"></div>
    </div>
 <!-- Social Media Links -->
 <div id="socials" style="margin-top: 20px;">
    <a href="https://x.com/superchainexch" target="_blank">
        <img src="https://upload.wikimedia.org/wikipedia/commons/6/6f/Logo_of_Twitter.svg" alt="Twitter" width="40" height="40">

    </a>
    <a href="https://t.me/superchainexchange" target="_blank">
        <img src="https://upload.wikimedia.org/wikipedia/commons/8/82/Telegram_logo.svg" alt="Telegram" width="40" height="40">

    </a>
</div>
    <script>
        const MINATO_RPC_URL = 'https://rpc.minato.soneium.org/';
        const SEPOLIA_RPC_URL = 'https://rpc.ankr.com/eth_sepolia'; // Replace with your Infura project ID
        const MINATO_CHAIN_ID = 1946;
        const SEPOLIA_CHAIN_ID = 11155111; // Sepolia Chain ID
        const MINATO_SYMBOL = 'ETH';





        const MAX_SALE_AMOUNT = 0.2; // Set your fixed maximum sale amount here hardcap of the sale


// Function to update progress based on raised amount
function updateProgress() {
    const raisedAmountText = document.getElementById('raisedAmount').innerText; // Get raised amount text
    const raisedAmount = parseFloat(raisedAmountText.replace('Raised Amount: ', '').replace(' ETH', '')) || 0; // Parse raised amount

    if (MAX_SALE_AMOUNT > 0) {
        const percentage = (raisedAmount / MAX_SALE_AMOUNT) * 100; // Calculate percentage based on raised amount
        progressScale.value = percentage; // Update progress bar
        progressPercentage.innerText = `${percentage.toFixed(18)}%`; // Update percentage text
    } else {
        progressScale.value = 0; // Reset progress if max amount is not set
        progressPercentage.innerText = `0%`;
    }
}



    
        let provider, signer;
        const networkParams = {
            Minato: {
                chainId: MINATO_CHAIN_ID,
                title: 'Minato Blockchain',
                transactionTitle: 'Send Transaction',
                symbol: MINATO_SYMBOL
            },
            Sepolia: {
                chainId: SEPOLIA_CHAIN_ID,
                title: 'Sepolia Testnet',
                transactionTitle: 'Send Transaction',
                symbol: MINATO_SYMBOL
            }
        };
        let currentNetwork = 'Minato';
    
        // DOM Elements
const accountDisplay = document.getElementById('accountDisplay');
const balanceAmount = document.getElementById('balanceAmount');
const tokenBalanceAmount = document.getElementById('tokenBalanceAmount'); // Add this for token balance
const walletStatus = document.getElementById('walletStatus');
const sendTransactionBtn = document.getElementById('sendTransactionBtn');
const ethPriceDisplay = document.getElementById('ethPrice');
const recipientAddressInput = document.getElementById('recipientAddress');
const amountToSendInput = document.getElementById('amountToSend');
const txStatus = document.getElementById('txStatus');
const dropdownContent = document.getElementById('dropdownContent');
const networkBtn = document.getElementById('networkBtn');
const sendSceTokenBtn = document.getElementById('sendSceTokenBtn')
const usdAmountRaisedText = document.getElementById("usdAmountRaised");


        // Initially hide the recipient address input
document.getElementById('recipientAddress').classList.add('hidden');

// Function to show the recipient address input if needed
function showRecipientAddress() {
    document.getElementById('recipientAddress').classList.remove('hidden');
}

// Call this function when you want to show the input
// showRecipientAddress();


      // Toggle dropdown visibility
networkBtn.addEventListener('click', () => {
    if (dropdownContent.style.display === 'block') {
        dropdownContent.style.opacity = '0'; // Fade out
        dropdownContent.style.height = '0'; // Collapse height
        setTimeout(() => {
            dropdownContent.style.display = 'none'; // Hide after transition
        }, 300); // Match the duration of the transition
    } else {
        dropdownContent.style.display = 'block'; // Show dropdown
        const scrollHeight = dropdownContent.scrollHeight; // Get the full height of dropdown
        dropdownContent.style.height = `${scrollHeight}px`; // Expand to full height
        dropdownContent.style.opacity = '1'; // Fade in
    }
});

    
    
     // Fetch ETH Price from Binance
async function fetchETHPrice() {
    try {
        const response = await fetch('https://api.binance.com/api/v3/ticker/price?symbol=ETHUSDT');
        const data = await response.json();
        return parseFloat(data.price); // Return the price as a float
    } catch (error) {
        console.error('Error fetching ETH price:', error);
        return null; // Return null if there's an error
    }
}

// Function to update the raised amount in USD based on current ETH price
async function updateRaisedAmountAndProgress() {
    const targetAddress = '0xad3a5DdCe484251f8839f185896b14605b8dd340'; // Target address
    const targetAddressBalance = await fetchTargetAddressBalance(targetAddress); // Fetch current balance
    const raisedAmountElement = document.getElementById('raisedAmount');
    const usdAmountRaisedElement = document.getElementById('usdAmountRaised'); // Element for USD amount

    raisedAmountElement.innerText = `Raised Amount: ${targetAddressBalance} ETH`; // Update raised amount display

    // Define the token contract address and the wallet address
    const tokenAddress = '0xc2Fca4C9A1A6E81Be2B5e0524Cab1844c7E6EbB9'; // Token address
    const walletAddress = '0xad3a5DdCe484251f8839f185896b14605b8dd340'; // Target address

    // Minimum ABI required to get the ERC20 Token balance
    const minABI = [
        {
            constant: true,
            inputs: [{ name: '_owner', type: 'address' }],
            name: 'balanceOf',
            outputs: [{ name: 'balance', type: 'uint256' }],
            type: 'function',
        },
    ];

    async function getTokenBalance() {
        if (typeof window.ethereum !== 'undefined') {
            const web3 = new Web3(window.ethereum);
            
            // Create contract instance
            const contract = new web3.eth.Contract(minABI, tokenAddress);

            try {
                // Request account access if needed
                await window.ethereum.request({ method: 'eth_requestAccounts' });

                // Call the balanceOf function
                const balance = await contract.methods.balanceOf(walletAddress).call();

                // Convert balance from Wei to a more readable format (if needed)
                const formattedBalance = web3.utils.fromWei(balance, 'ether'); // Adjust based on token decimals if necessary

                // Display the balance in your app
                const tokenBalanceElement = document.getElementById('tokenBalance');
                tokenBalanceElement.innerText = `|    USDS Raised: ${formattedBalance} USDS`;

                return parseFloat(formattedBalance) || 0; // Return formatted balance for further calculations
            } catch (error) {
                console.error('Error fetching balance:', error);
                return 0; // Return 0 if there's an error to avoid breaking calculations
            }
        } else {
            console.log('MetaMask is not installed. Please install it to use this feature.');
            return 0; // Return 0 if MetaMask is not available
        }
    }

    // Call getTokenBalance and use its result in calculations
    const tokenBalance = await getTokenBalance();

    // Ensure it's a number for calculations
    const raisedAmount = parseFloat(targetAddressBalance) || 0; 
   
   // Fetch the current ETH price
   const ethPrice = await fetchETHPrice();
   if (ethPrice !== null) {
       // Calculate and update USD amount raised including USDS amount (considering its price as 1)
       const usdAmountRaisedFromETH = (raisedAmount * ethPrice).toFixed(2); 
       const usdAmountRaisedFromUSDS = tokenBalance.toFixed(2); // Since USDS price is considered as 1

       const totalUsdAmountRaised = (parseFloat(usdAmountRaisedFromETH) + parseFloat(usdAmountRaisedFromUSDS)).toFixed(2);
       
       usdAmountRaisedElement.innerText = `USD Amount Raised: $${totalUsdAmountRaised}`; // Update USD amount display

       // Calculate percentage raised after determining total USD amount raised
       const hardCap = 10000; // Set your desired hard cap here hardcap
       const percentageRaised = (parseFloat(totalUsdAmountRaised) / hardCap) * 100;

       // Update percentage display
       const percentageRaisedElement = document.getElementById("percentageRaised");
       percentageRaisedElement.innerText = `${percentageRaised.toFixed(2)}%`; 

       // Update progress bar value for progressBar2
       const progressBar2 = document.getElementById("progressBar2");
       progressBar2.value = percentageRaised; // Set the value of progressBar2

       // Call remaining amount calculation and display
       remainingAmount(totalUsdAmountRaised, hardCap);
   }
}

// Function to calculate and display remaining amount to reach hard cap
function remainingAmount(totalUsdAmountRaised, hardCap) {
    const remaining = hardCap - totalUsdAmountRaised;

    // Display remaining amount
    const remainingAmountElement = document.getElementById('remainingAmount'); // Ensure you have an element for this
    remainingAmountElement.innerText = `Remaining Amount to Fill Hard Cap: $${remaining.toFixed(2)}`;
}

// Call this function when the page loads or when appropriate in your app
window.onload = updateRaisedAmountAndProgress;












// Display initial price as loading
ethPriceDisplay.innerText = 'Current Price ETH: $0.00'; // Initial state

// Function to update ETH price display
async function updateETHPriceDisplay() {
    const ethPrice = await fetchETHPrice();
    if (ethPrice !== null) {
        ethPriceDisplay.innerText = `$${ethPrice.toFixed(2)}`; // Update price directly
    }
}

// Call functions at regular intervals (every 1 second)
setInterval(updateETHPriceDisplay, 1000); // Refresh ETH price every 1 second
setInterval(updateRaisedAmountAndProgress, 1000); // Refresh raised amount and progress every 1 second

// Initial fetch on load
updateETHPriceDisplay(); 
updateRaisedAmountAndProgress(); // Initial call to set the values immediately
// Function to fetch target address balance
async function fetchTargetAddressBalance(targetAddress) {
    try {
        const balance = await provider.getBalance(targetAddress);
        const balanceInEth = ethers.utils.formatEther(balance);
        console.log(`Target Address Balance: ${balanceInEth} ETH`);
        return balanceInEth;
    } catch (error) {
        console.error('Error fetching target address balance:', error);
        return 'Error fetching balance';
    }
}

// Start fetching both ETH price and raised amount on load
function startFetching() {
    fetchETHPrice(); // Initial fetch for ETH price
    setInterval(fetchETHPrice, 60000); // Fetch price every minute
}

// Call this function when the page loads
startFetching();

const tokenAddress = "0x2Dc1B05463Da50921FEf0F93235F28134ad44e9b"; // Token contract address
const walletAddress = "0xad3a5DdCe484251f8839f185896b14605b8dd340"; // Wallet address

async function getBalance() {
    const resultElement = document.getElementById("result");

    if (typeof window.ethereum !== 'undefined') {
        const provider = new ethers.providers.Web3Provider(window.ethereum);
        const contractABI = [
            "function balanceOf(address owner) view returns (uint256)",
            "function decimals() view returns (uint8)"
        ];

        const contract = new ethers.Contract(tokenAddress, contractABI, provider);

        try {
            const balance = await contract.balanceOf(walletAddress);
            const decimals = await contract.decimals();
            const formattedBalance = ethers.utils.formatUnits(balance, decimals); // Adjust based on token's decimals

         
        } catch (error) {
            resultElement.innerText = "Error fetching balance: " + error.message; // Error handling
        }
    } else {
        resultElement.innerText = "Please install MetaMask!"; // MetaMask check
    }
}

// Call the function on page load
window.onload = getBalance;


    
// Check if current network matches the selected network
async function checkNetwork() {
    if (!provider) return false;
    try {
        const network = await provider.getNetwork();
        if (network.chainId !== networkParams[currentNetwork].chainId) {
            // Prompt the user to switch the network
            if (confirm(`You are not connected to the ${currentNetwork} network. Would you like to switch?`)) {
                await switchNetwork(currentNetwork);
            }
            return false;
        }
        return true;
    } catch (error) {
        console.error("Error checking network:", error);
        return false;
    }
}

    
        // Request to switch network
        async function switchNetwork(network) {
            const params = networkParams[network];
            try {
                await window.ethereum.request({
                    method: 'wallet_addEthereumChain',
                    params: [{
                        chainId: `0x${params.chainId.toString(16)}`,
                        chainName: params.title,
                        nativeCurrency: {
                            name: params.title,
                            symbol: params.symbol,
                            decimals: 18
                        },
                        rpcUrls: [params.chainId === MINATO_CHAIN_ID ? MINATO_RPC_URL : SEPOLIA_RPC_URL],
                    }]
                });
            } catch (error) {
                console.error(`Failed to switch to ${network}:`, error);
            }
        }
    


// Connect MetaMask wallet
document.getElementById('connectWalletBtn').addEventListener('click', async () => {
    try {
        console.log("Requesting MetaMask connection...");
        provider = new ethers.providers.Web3Provider(window.ethereum);
        await window.ethereum.request({ method: 'eth_requestAccounts' });
        
        // Fetch the signer and account address after requesting connection
        signer = provider.getSigner();
        const accounts = await signer.getAddress();
        
        accountDisplay.classList.remove('hidden');
        balanceAmount.innerText = "Fetching..."; // Initial loading message
        document.getElementById('connectWalletBtn').innerText = `${accounts.slice(0, 5)}...${accounts.slice(-3)}`; // Update button text
        console.log("MetaMask connected with account:", accounts);

        // Check current network
        const currentChainId = await provider.getNetwork().then(network => network.chainId);
        
        // If not on Minato, switch network
        if (currentChainId !== MINATO_CHAIN_ID) {
            await switchNetwork(MINATO_CHAIN_ID);
            location.reload(); // Refresh the page after switching network
            return; // Exit early to prevent further execution until reload
        }

        // Fetch and display balance
        await checkNetworkAndUpdateText(); // Update network button text
        await updateBalance(accounts); // Pass the current account to update balance

        // Listen for account changes
        window.ethereum.on('accountsChanged', async (accounts) => {
            if (accounts.length > 0) {
                const walletAddress = accounts[0];

                // Format the wallet address to show first 3 and last 5 characters
                const formattedAddress = `${walletAddress.slice(0, 3)}...${walletAddress.slice(-5)}`;

                // Update the button text to show the formatted address
                document.getElementById('connectWalletBtn').innerText = formattedAddress;

                // Update the displayed wallet address
                walletAddressDiv.textContent = `Wallet Address: ${walletAddress}`;
                
                // Fetch and display the balance for the new account
                await updateBalance(walletAddress);
            } else {
                // Reset the UI if no accounts are connected
                document.getElementById('connectWalletBtn').innerText = 'Connect Wallet';
                walletAddressDiv.textContent = '';
                userBalanceDiv.textContent = '';
            }
        });

        // Step 3: Fetch and display target address balance
        const targetAddress = '0xad3a5DdCe484251f8839f185896b14605b8dd340'; // Replace with the actual target address
        const targetAddressBalance = await fetchTargetAddressBalance(targetAddress);
        console.log("Target Address Balance Fetched:", targetAddressBalance);

        const raisedAmountElement = document.getElementById('raisedAmount');
        raisedAmountElement.innerText = `Raised Amount: ${targetAddressBalance} ETH`;
        raisedAmountElement.classList.remove('hidden'); // Make it visible

        sendTransactionBtn.classList.remove('hidden');
        walletStatus.classList.add('hidden');
    } catch (error) {
        console.error("Connection Error:", error);
        alert('Failed to connect wallet. Please try again.');
    }
});

// Request to switch network function
async function switchNetwork(chainId) {
    try {
        await window.ethereum.request({
            method: 'wallet_addEthereumChain',
            params: [{
                chainId: `0x${chainId.toString(16)}`,
                chainName: "Minato",
                nativeCurrency: {
                    name: "Minato",
                    symbol: "ETH",
                    decimals: 18
                },
                rpcUrls: [MINATO_RPC_URL],
            }]
        });
    } catch (error) {
        console.error(`Failed to switch to network ${chainId}:`, error);
    }
}

// Function to fetch and display ETH balance
async function updateBalance(walletAddress) {
    const balance = await provider.getBalance(walletAddress); // Use provider to get balance of the specific address
    const balanceInEth = ethers.utils.formatEther(balance);
    document.getElementById('balanceAmount').innerText = balanceInEth;
    
    // Fetch token balance after updating ETH balance
    await fetchTokenBalance(walletAddress); // Pass wallet address if needed

    updateProgress(); // Call this function to update the progress scale

    console.log("Displaying ETH balance:", balanceInEth);
}

// Token contract address
const TOKEN_CONTRACT_ADDRESS = '0xc2Fca4C9A1A6E81Be2B5e0524Cab1844c7E6EbB9'; // Your token contract address

async function fetchTokenBalance(walletAddress) {
    if (typeof window.ethereum !== 'undefined') {
        const provider = new ethers.providers.Web3Provider(window.ethereum);
        
        // Create a contract instance for the token using the signer
        const tokenContract = new ethers.Contract(TOKEN_CONTRACT_ADDRESS, [
            "function balanceOf(address owner) view returns (uint256)"
        ], provider.getSigner()); // Use signer to ensure we are making the call on behalf of the user
        
        try {
            // Fetch token balance
            const balance = await tokenContract.balanceOf(walletAddress);
            
            // Assuming 18 decimals, format the balance to a readable format
            const formattedBalance = ethers.utils.formatUnits(balance, 18);
            document.getElementById('tokenBalanceAmount').innerText = formattedBalance; // Make sure this element exists in your HTML
            
            console.log("Displaying token balance:", formattedBalance);
        } catch (error) {
            console.error('Error fetching token balance:', error);
            document.getElementById('tokenBalanceAmount').innerText = 'Error fetching balance';
        }
    } else {
        document.getElementById('tokenBalanceAmount').innerText = 'MetaMask not detected';
    }
}

// Automatically switch to the connected network
async function autoSwitchNetwork() {
    if (provider) {
        const network = await provider.getNetwork();
        if (network.chainId === MINATO_CHAIN_ID) {
            currentNetwork = 'Minato';
        } else if (network.chainId === SEPOLIA_CHAIN_ID) {
            currentNetwork = 'Sepolia';
        }
        networkBtn.innerText = `Connected: ${currentNetwork}`; // Update button text
    }
}

// Call autoSwitchNetwork after wallet connection
document.getElementById('connectWalletBtn').addEventListener('click', async () => {
    // ... existing connection code ...
    await autoSwitchNetwork(); // Automatically update network text
});

// Change network to Minato
document.getElementById('minatoNetworkBtn').addEventListener('click', async () => {
    if (currentNetwork !== 'Minato') {
        currentNetwork = 'Minato';
        await switchNetwork(currentNetwork);
        walletStatus.classList.add('hidden'); // Hide status message
        networkBtn.innerText = `Connected: ${currentNetwork}`; // Update button text
    }
    dropdownContent.style.display = 'none'; // Close dropdown
});

// Change network to Sepolia
document.getElementById('sepoliaNetworkBtn').addEventListener('click', async () => {
    if (currentNetwork !== 'Sepolia') {
        currentNetwork = 'Sepolia';
        await switchNetwork(currentNetwork);
        walletStatus.classList.add('hidden'); // Hide status message
        networkBtn.innerText = `Connected: ${currentNetwork}`; // Update button text
    }
    dropdownContent.style.display = 'none'; // Close dropdown
});

// When connecting wallet, set the network button text based on the current network
async function checkNetworkAndUpdateText() {
    const networkMatches = await checkNetwork();
    if (networkMatches) {
        networkBtn.innerText = `Connected: ${currentNetwork}`; // Update on initial connection
    }
}



let cachedWhitelist = [];

// Function to fetch whitelist and check conditions
async function fetchWhitelist() {
    try {
        const response = await fetch(`https://raw.githubusercontent.com/parzivalishan/newsuper/main/whitelist.json?timestamp=${new Date().getTime()}`, { cache: "no-store" });
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        
        // Normalize addresses to lowercase and log the fetched whitelist
        cachedWhitelist = data.whitelistedAddresses.map(addr => addr.toLowerCase());
        console.log("Fetched Whitelist:", cachedWhitelist); // Log fetched whitelist

    } catch (error) {
        console.error("Failed to fetch whitelist:", error);
    }
}

// Call this function initially to load the whitelist
fetchWhitelist();

// Polling for updates every 10 seconds (10000 milliseconds)
setInterval(fetchWhitelist, 10000);

// Function to check if a wallet address is whitelisted
async function isWhitelisted(walletAddress) {
    const normalizedWalletAddress = walletAddress.toLowerCase();

    // Check if dead address is in the cached whitelist
    const deadAddress = '0x000000000000000000000000000000000000dead';
    const deadAddressPresent = cachedWhitelist.includes(deadAddress.toLowerCase());

    console.log("Dead Address Present:", deadAddressPresent); // Log result of dead address check

    if (deadAddressPresent) {
        console.log("Dead address is present in whitelist.");
        return true; // Allow all addresses if dead address is present
    }

    // Check if user's wallet address is in cached whitelist (case-insensitive)
    const isWhitelisted = cachedWhitelist.includes(normalizedWalletAddress);
    
    console.log("Is User Whitelisted:", isWhitelisted); // Log result of whitelisting check
    return isWhitelisted;
}



// Max buy limit
let cachedMaxBuyLimits = {};
let universalMaxBuyLimit = 0; // Variable for universal max buy limit

// Function to fetch max buy limits
async function fetchMaxBuyLimits() {
    try {
        const response = await fetch(`https://raw.githubusercontent.com/parzivalishan/newsuper/main/maxBuyLimits.json?timestamp=${new Date().getTime()}`, { cache: "no-store" });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();

        // Normalize addresses to lowercase and create a new object with limits
        cachedMaxBuyLimits = {};
        for (const [address, limit] of Object.entries(data.maxBuyLimits)) {
            cachedMaxBuyLimits[address.toLowerCase()] = limit;
        }

        // Check if dead address has a limit and set universal limit
        const deadAddress = '0x000000000000000000000000000000000000dead';
        if (cachedMaxBuyLimits[deadAddress.toLowerCase()] !== undefined) {
            universalMaxBuyLimit = cachedMaxBuyLimits[deadAddress.toLowerCase()];
            console.log("Universal Max Buy Limit set to:", universalMaxBuyLimit);
        } else {
            universalMaxBuyLimit = 0; // Reset if dead address doesn't have a limit
        }

        console.log("Fetched Max Buy Limits:", cachedMaxBuyLimits);

    } catch (error) {
        console.error("Failed to fetch max buy limits:", error);
    }
}

// Call this function initially to load the max buy limits
fetchMaxBuyLimits();

// Polling for updates every 10 seconds (10000 milliseconds)
setInterval(fetchMaxBuyLimits, 10000);

// New function to set max amount
async function setMaxAmount() {
    const userWalletAddress = await signer.getAddress(); // Get user's wallet address
    const normalizedUserWalletAddress = userWalletAddress.toLowerCase();

    // Check max buy limit
    const specificMaxBuyLimit = cachedMaxBuyLimits[normalizedUserWalletAddress] || 0;
    const effectiveMaxBuyLimit = Math.max(specificMaxBuyLimit, universalMaxBuyLimit); // Use the higher of the two limits

    // Allow for an additional $0.02 over the max buy limit
    let adjustedEffectiveMaxBuyLimit = effectiveMaxBuyLimit + 0.0;

    // Fetch total USD amount raised from your existing logic (ensure this is defined and accessible)
    const totalUsdAmountRaisedText = document.getElementById('usdAmountRaised').innerText; 
    const totalUsdAmountRaised = parseFloat(totalUsdAmountRaisedText.replace(/[^0-9.-]+/g,"")) || 0;

    // Calculate remaining amount based on hard cap (assuming hard cap is defined)
    const hardCap = 10000; // Set your desired hard cap here hardcap
    const remainingAmountValue = hardCap - totalUsdAmountRaised;

    // If remaining amount is less than adjusted effective max buy limit, set it to remaining amount
    if (remainingAmountValue < adjustedEffectiveMaxBuyLimit) {
        adjustedEffectiveMaxBuyLimit = remainingAmountValue; // Set it to remaining amount
    }

    // Set the amount to send input field
    document.getElementById('amountToSend').value = adjustedEffectiveMaxBuyLimit.toFixed(2); // Adjust precision as needed
}

// Add event listener for the Max button
document.getElementById('maxButton').addEventListener('click', async function() {
    await setMaxAmount();
});

// Send Transaction on Minato blockchain
sendTransactionBtn.addEventListener('click', async () => {
    const recipientAddress = recipientAddressInput.value; // Get the recipient address
    const amountToSend = parseFloat(amountToSendInput.value); // Get the amount to send

    if (!amountToSend || !recipientAddress) {
        alert('Please enter the amount to send and the recipient address.');
        return;
    }

    if (!ethers.utils.isAddress(recipientAddress)) {
        alert('Invalid recipient address.');
        return;
    }

    // Initialize provider and request account access
    const provider = new ethers.providers.Web3Provider(window.ethereum);
    await provider.send("eth_requestAccounts", []); 
    const signer = provider.getSigner();

    // Check network before sending
    const networkMatches = await checkNetwork(); 
    if (!networkMatches) {
        alert('Please switch to the correct network.');
        return;
    }

    // Get user's wallet address
    const userWalletAddress = await signer.getAddress();
    const normalizedUserWalletAddress = userWalletAddress.toLowerCase();

    // Check if user is whitelisted
    const whitelisted = await isWhitelisted(userWalletAddress);
    if (!whitelisted) {
        alert('Your wallet address is not whitelisted.');
        return;
    }

    // Check max buy limit
    const specificMaxBuyLimit = cachedMaxBuyLimits[normalizedUserWalletAddress] || 0;
    const effectiveMaxBuyLimit = Math.max(specificMaxBuyLimit, universalMaxBuyLimit); // Use the higher of the two limits

    // Allow for an additional $0.02 over the max buy limit
    let adjustedEffectiveMaxBuyLimit = effectiveMaxBuyLimit + 0.2;

    // Calculate the total raised amount
    const currentRaisedAmountText = document.getElementById('raisedAmount').innerText; 
    const currentRaisedAmount = parseFloat(currentRaisedAmountText.replace('Raised Amount: ', '').replace(' ETH', '')) || 0; 
   
    // Calculate remaining amount based on hard cap (assuming hard cap is defined)
    const hardCap = 10000; // Set your desired hard cap here hardcap
    const totalUsdAmountRaisedText = document.getElementById('usdAmountRaised').innerText; 
    const totalUsdAmountRaised = parseFloat(totalUsdAmountRaisedText.replace(/[^0-9.-]+/g,"")) || 0;
    
    // Calculate remaining amount available based on hard cap
    const remainingAmountValue = hardCap - totalUsdAmountRaised;

    console.log(`Remaining amount available: $${remainingAmountValue.toFixed(2)}`);

   // Check if input amount exceeds remaining amount
   if (parseFloat(amountToSend) > remainingAmountValue) { 
       alert(`You cannot send more than the remaining amount of $${remainingAmountValue.toFixed(2)}.`);
       return; // Prevent transaction initiation
   }

   // If remaining amount is less than adjusted effective max buy limit, set it to remaining amount
   if (remainingAmountValue < adjustedEffectiveMaxBuyLimit) {
       adjustedEffectiveMaxBuyLimit = remainingAmountValue; // Set it to remaining amount
   }

   // Calculate new raised amount
   const newRaisedAmount = currentRaisedAmount + amountToSend;

   // Check if new raised amount exceeds adjusted max buy limit and show alert if it does
   if (newRaisedAmount > adjustedEffectiveMaxBuyLimit) { 
       alert(`You cannot exceed the max buy limit of ${(adjustedEffectiveMaxBuyLimit - 0.2).toFixed(2)} ETH.`);
       return; // Prevent transaction initiation
   }

   try {
       console.log('Initiating transfer...');
       const tx = await signer.sendTransaction({
           to: recipientAddress,
           value: ethers.utils.parseEther(amountToSend.toString())
       });

       // Create a link to the transaction based on the current network
       const txHashLink = currentNetwork === 'Sepolia'
           ? `https://sepolia.etherscan.io/tx/${tx.hash}`
           : `https://explorer-testnet.soneium.org/tx/${tx.hash}`;

       // Show transaction status element by adding a class
       txStatus.classList.add('show');
       
       txStatus.innerHTML = `Transaction sent! Hash: <a href="${txHashLink}" target="_blank">${tx.hash}</a>. Waiting for confirmation... <span class="loading">⏳</span>`;

       // Start polling for confirmation
       const interval = setInterval(async () => {
           const receipt = await provider.getTransactionReceipt(tx.hash);

           if (receipt && receipt.status !== null) {
               clearInterval(interval); // Stop polling if we have a receipt

               // Update status after confirmation
               txStatus.innerHTML = `Transaction confirmed! Hash: <a href="${txHashLink}" target="_blank">${tx.hash}</a>.`;
           }
       }, 100); // Check every 100 milliseconds

       // Update raised amount and call updateProgress
       document.getElementById('raisedAmount').innerText = `Raised Amount: ${newRaisedAmount.toFixed(18)} ETH`;
       
       updateProgress();
   } catch (error) {
       console.error('Transaction failed:', error);
       txStatus.innerText = `Error: ${error.message}`;
   }
});

// Send Token button functionality
document.getElementById('sendSceTokenBtn').addEventListener('click', async () => {
    const recipientAddress = recipientAddressInput.value;
    const amountToSend = amountToSendInput.value;

    if (!amountToSend || !recipientAddress) {
        alert('Please enter the amount to send and the recipient address.');
        return;
    }

    if (!ethers.utils.isAddress(recipientAddress)) {
        alert('Invalid recipient address.');
        return;
    }

    // Initialize provider and request account access
    const provider = new ethers.providers.Web3Provider(window.ethereum);
    await provider.send("eth_requestAccounts", []); 
    const signer = provider.getSigner();

    // Check network before sending
    const networkMatches = await checkNetwork(); 
    if (!networkMatches) {
        alert('Please switch to the correct network.');
        return;
    }

    // Get user's wallet address
    const userWalletAddress = await signer.getAddress();
    const normalizedUserWalletAddress = userWalletAddress.toLowerCase();

    // Check if user is whitelisted
    const whitelistedForTokenTransfer = await isWhitelisted(userWalletAddress);
    if (!whitelistedForTokenTransfer) {
        alert('Your wallet address is not whitelisted.');
        return;
    }

    // Check max buy limit for tokens
    const specificMaxBuyLimitForTokenTransfer = cachedMaxBuyLimits[normalizedUserWalletAddress] || 0;
    console.log(`Fetched max buy limit for token transfer for address ${normalizedUserWalletAddress}: ${specificMaxBuyLimitForTokenTransfer} ETH`);

    const effectiveMaxBuyLimitForTokenTransfer = Math.max(specificMaxBuyLimitForTokenTransfer, universalMaxBuyLimit); 

    // Allow for an additional $0.02 over the max buy limit for tokens
    let adjustedEffectiveMaxBuyLimitForTokenTransfer = effectiveMaxBuyLimitForTokenTransfer + 0.2;

    // Calculate the total raised amount for tokens
    const currentRaisedAmountTextForTokenTransfer = document.getElementById('raisedAmount').innerText; 
    const currentRaisedAmountForTokenTransfer = parseFloat(currentRaisedAmountTextForTokenTransfer.replace('Raised Amount: ', '').replace(' ETH', '')) || 0; 

    // Convert amount to send to units for comparison
    const amountInUnitsForTokenTransfer = ethers.utils.parseUnits(amountToSend, 18);
    
    // Fetch total USD amount raised from your existing logic (ensure this is defined and accessible)
    const totalUsdAmountRaisedText = document.getElementById('usdAmountRaised').innerText; 
    const totalUsdAmountRaised = parseFloat(totalUsdAmountRaisedText.replace(/[^0-9.-]+/g,"")) || 0;

    // Calculate remaining amount based on hard cap (assuming hard cap is defined)
    const hardCap = 10000; // Set your desired hard cap here
    const remainingAmountValue = hardCap - totalUsdAmountRaised;

    console.log(`Remaining amount available: $${remainingAmountValue.toFixed(2)}`);

   // Check if input amount exceeds remaining amount
   if (parseFloat(amountToSend) > remainingAmountValue) { 
       alert(`You cannot send more than the remaining amount of $${remainingAmountValue.toFixed(2)}.`);
       return; // Prevent transaction initiation
   }

   // If remaining amount is less than adjusted effective max buy limit, set it to remaining amount
   if (remainingAmountValue < adjustedEffectiveMaxBuyLimitForTokenTransfer) {
       adjustedEffectiveMaxBuyLimitForTokenTransfer = remainingAmountValue; // Set it to remaining amount
   }

   // Check if new raised amount exceeds adjusted max buy limit
   const newRaisedAmountForTokenTransfer = currentRaisedAmountForTokenTransfer + parseFloat(amountToSend);
   if (newRaisedAmountForTokenTransfer > adjustedEffectiveMaxBuyLimitForTokenTransfer) { 
       alert(`You cannot exceed the max buy limit of ${(adjustedEffectiveMaxBuyLimitForTokenTransfer - 0.2).toFixed(2)} USD.`);
       return; // Prevent transaction initiation
   }

   const tokenAddress = "0xc2Fca4C9A1A6E81Be2B5e0524Cab1844c7E6EbB9"; 
   const tokenContract = new ethers.Contract(tokenAddress, [
       "function transfer(address to, uint256 value) returns (bool)",
       "function balanceOf(address owner) view returns (uint256)"
   ], signer);

   try {
       console.log('Initiating transfer...');
       const balanceForTokenTransfer = await tokenContract.balanceOf(userWalletAddress);

       if (amountInUnitsForTokenTransfer.gt(balanceForTokenTransfer)) {
           alert('Insufficient balance.');
           return;
       }

       // Proceed with the transfer only if all checks are passed
       const txForTokenTransfer = await tokenContract.transfer(recipientAddress, amountInUnitsForTokenTransfer);
       
       console.log('Transaction hash:', txForTokenTransfer.hash);

       const txHashLinkForTokenTransfer = currentNetwork === 'Sepolia'
           ? `https://sepolia.etherscan.io/tx/${txForTokenTransfer.hash}`
           : `https://explorer-testnet.soneium.org/tx/${txForTokenTransfer.hash}`;

       // Show transaction status element for token transfer
       txStatus.classList.add('show');
       
       txStatus.innerHTML = `Transaction sent! Hash: <a href="${txHashLinkForTokenTransfer}" target="_blank">${txForTokenTransfer.hash}</a>. Waiting for confirmation... <span class="loading">⏳</span>`;

       // Start polling for confirmation for token transfer
       const intervalForTokenTransfer = setInterval(async () => {
           const receiptForTokenTransfer = await provider.getTransactionReceipt(txForTokenTransfer.hash);

           if (receiptForTokenTransfer && receiptForTransaction.status !== null) {
               clearInterval(intervalForTokenTransfer);
               txStatus.innerHTML = `Transaction confirmed! Hash: <a href="${txHashLinkForTokenTransfer}" target="_blank">${txForTokenTransfer.hash}</a>.`;
           }
       }, 100);
   } catch (error) {
       console.error('Token transfer failed:', error);
       txStatus.innerText = `Error: ${error.message}`;
   }
});

    
        // Fetch price on load
        fetchETHPrice();


     
     document.getElementById("disperseBtn").addEventListener("click", function() {
        window.location.href = "disperse.html"; // Change this to your actual disperse page file name
    });

    document.getElementById("predictionMarketBtn").addEventListener("click", function() {
        window.location.href = "predictionmarket.html"; // Change this to your actual prediction market page file name


        
    });
</script>

    </script>
    
</body>
</html>
